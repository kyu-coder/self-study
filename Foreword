It doesn't matter what the programs are about or what applications they serve.
What does matter is how well they perform and how smoothly they fit with other programs.
The programmer must seek both perfection of part and adequacy of collection.

Three foci of phenomena: 
1. the human mind
2. collections of computer programs
3. the computer
Every computer program is a model, hatched in the mind, of a real or mental process.
If art interprets our dreams, the computer executes them in the guise of programs!

Since large programs grow from small ones, it is crucial that we develop an arsenal
of standard program structures of whose correctness we have become sure -- we call them idioms
-- and learn to combine them into larger structures using organizational techniques
of proven value.

Unlike programs, computers must obey the laws of physics.
The process that transform out Lisp programs to 'machine' programs are themselves 
abstract models which we program.

A programmer should acquire good algorithms and idioms.
Even though some programs resist precist specifications, it is the responsiblity of the 
programmer to estimate, and always to attempt to improve, their performance.

In any very large programming task a useful organizing principle is to control and isolate
traffic within the task modules via the invention of language.

Our design of this introductory computer-science subject reflects two major concerns.
First,
	we want to establish the idea that a computer language is not just a way of getting
	a computer to perform operations but rather that it is a novel formal medium for 
	expressing ideas about methodology.
	Thus, programs must be written for people to read, and only incidentally for machines
	to execute.
Second,
	we believe that the essential material to be addressed by a subject at this level 
	is not the syntax of particular programming-language constructs, nor clever algorithms 
	for computing particular functions efficiently, nor even the mathematical analysis
	of algorithms and the foundations of computing, but rather the techniques
	used to control the intellectual complexity of large software systems.

The computer revolution is a revolution in the way we think and in the way we express what we think.


